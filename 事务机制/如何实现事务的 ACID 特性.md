# 如何实现一致性

事务一致性的实现需要运用事务的原子性、隔离性和持久性。并且还要考虑事务执行的最终结果，是否满足我们事先定义好的约束规则，这就需要数据库层提供的约束检测，并且在应用层开发中做好相关的约束检测，如果检测发现事务的执行结果不满足我们事先定义好的约束规则，那么就需要将事务回滚，使数据处于之前的一致性状态。

也就是说，数据库本身只能为我们保证一部分一致性需求，更多的一致性需求需要程序员在应用层写业务代码自己保证。

------

举例说明

下面我们举一个【账户 A 向 账户 B 转账】的例子来说明事务一致性的实现：

在账户 A 向 账户 B 转账时，转账前后，我们定义账户 A 和 账户 B 必须满足以下的约束规则：

- 账户的余额必须大于等于 0（字段取值范围的有效性可以用 check 约束来检测）
- 转账前后，账户 A 和账户 B 的总余额必须相同（这个约束需要运用事务的原子性、隔离性、持久性来保证）

转账操作执行完成后，提交事务前，我们还需要检测此时的数据是否满足我们定义好的约束规则：

- 如果不满足的话，说明此时的数据不是处于一致性的状态，那么就回滚事务，使数据处于之前的一致性状态。
- 如果满足的话，说明此时的数据处于一致性的状态，可以提交事务。

------

数据库层提供的约束检测

对键进行约束

- 主键约束：主键可以保证 unique + not null
- 外键约束：外键保证了表与表之间引用的完整性

除了对键进行约束外，还有字段约束

- 唯一性约束：用来检测字段在表中的数值是否唯一的（unique 索引）
- not null 约束：用来检测字段的值是否为空
- check 约束：用来检测字段取值范围的有效性（MySQL 仅支持 check 语法，但实际上并不起约束作用）



# 如何实现原子性

事务的原子性只关注整体的不可分割性，一个事务所有的操作，要么全部执行，要么一个都不执行，即 all-or nothing。

那么如何实现事务的原子性呢？从不可分割性的角度来思考，实现一个事务需要解决两个维度上的操作分割：

- 第一个维度是单节点上运行的事务，即单节点上操作的不可分割性（也就是一个节点上的操作，要么全部执行，要么一个都不执行）。
- 第二个维度是多节点上运行的事务，即多节点之间的操作的不可分割性（也就是多个节点的操作，要么全部节点都执行，要么一个节点都不执行）。

对于本地事务来说，只需要实现单节点上操作的不可分割性即可。

而对于分布式事务来说，不仅要实现单节点上操作的不可分割性，还要实现多节点之间的操作的不可分割性。

------

本地事务实现原子性，一般是在存储引擎上，使用 “Write-Ahead Log” 日志方案实现本地事务的原子性、持久性。

具体实现思路看我的另一篇文章《日志：Redo Log 和 Undo Log》。

---

分布式事务实现原子性，不仅要实现单节点上操作的不可分割性，还要实现多节点之间的操作的不可分割性。

对于单节点上操作的不可分割性，可以通过“Write-Ahead Log”日志方案实现。

现在我们只需要保证，多节点之间的操作的不可分割性，即多个节点的操作要么全部节点都执行，要么一个节点都不执行。一个常见的思路是通过两阶段提交（ 2PC ）来解决。

# 如何实现隔离性





# 如何保障持久性

